name: GenAI QA Test Integration

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  ai-testing:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Find source file to test
        id: find_file
        run: |
          # Find first source file (Python, JavaScript, TypeScript, or Java)
          file=$(find . -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.java" \) | head -n 1)
          if [ -z "$file" ]; then
            echo "No source files found"
            exit 1
          fi
          echo "Found file: $file"
          echo "source_file=$file" >> $GITHUB_OUTPUT

      - name: Login and get JWT token
        id: login
        run: |
          echo "ðŸ” Authenticating with backend..."
          
          # Login and capture the Set-Cookie header with the JWT token
          response=$(curl -s -i -X POST "${{ secrets.BACKEND_URL }}/api/login" \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@example.com","password":"admin123"}')
          
          # Extract HTTP status
          http_code=$(echo "$response" | grep -oP 'HTTP/\S+ \K\d+' | head -n 1)
          
          echo "HTTP Status: $http_code"
          
          if [ "$http_code" != "200" ]; then
            echo "âŒ Login failed with status $http_code"
            echo "$response"
            exit 1
          fi
          
          # Extract JWT token from Set-Cookie header
          token=$(echo "$response" | grep -i 'set-cookie: access_token=' | sed 's/.*access_token=\([^;]*\).*/\1/' | tr -d '\r')
          
          if [ -z "$token" ]; then
            echo "âŒ Failed to extract token from Set-Cookie header"
            echo "Response headers:"
            echo "$response" | head -n 20
            exit 1
          fi
          
          echo "âœ… Successfully authenticated"
          
          # Mask token in logs
          echo "::add-mask::$token"
          
          # Store token for subsequent steps
          echo "JWT_TOKEN=$token" >> $GITHUB_ENV

      - name: Prepare source code for testing
        id: prepare_code
        run: |
          source_file="${{ steps.find_file.outputs.source_file }}"
          
          # Read and base64 encode the file
          encoded_code=$(cat "$source_file" | base64 -w 0)
          echo "encoded_code=$encoded_code" >> $GITHUB_OUTPUT
          
          # Detect language from extension
          if [[ "$source_file" == *.py ]]; then
            echo "language=python" >> $GITHUB_OUTPUT
          elif [[ "$source_file" == *.js ]]; then
            echo "language=javascript" >> $GITHUB_OUTPUT
          elif [[ "$source_file" == *.ts ]]; then
            echo "language=typescript" >> $GITHUB_OUTPUT
          elif [[ "$source_file" == *.java ]]; then
            echo "language=java" >> $GITHUB_OUTPUT
          else
            echo "language=python" >> $GITHUB_OUTPUT
          fi

      - name: Generate tests via backend
        id: generate_tests
        run: |
          echo "ðŸ¤– Generating AI tests..."
          
          # Decode the source code
          decoded_code=$(echo "${{ steps.prepare_code.outputs.encoded_code }}" | base64 -d)
          
          # Build JSON payload using Python to avoid shell escaping issues
          json_payload=$(python3 -c "
          import json
          import sys

          code = '''$decoded_code'''
          language = '${{ steps.prepare_code.outputs.language }}'

          payload = {
              'message': code,
              'context': 'Automated test generation via GitHub Actions CI/CD',
              'language': language,
              'config': {
                  'framework': 'pytest' if language == 'python' else 'jest',
                  'coverage_target': 85,
                  'test_types': ['unit', 'integration'],
                  'mocking': True
              }
          }

          print(json.dumps(payload))
          ")
          
          # Call the API with JWT token in Authorization header
          response=$(curl -s -w "\n%{http_code}" -X POST "${{ secrets.BACKEND_URL }}/api/generate-tests" \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$json_payload")
          
          # Split response and status code
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          
          echo "HTTP Status: $http_code"
          
          if [ "$http_code" != "200" ]; then
            echo "âŒ Test generation failed with status $http_code"
            echo "Response: $body"
            exit 1
          fi
          
          # Save generated tests
          echo "$body" > generated_tests.json
          echo "âœ… Tests generated successfully"
          
          # Extract request_id (used for tracking in database)
          request_id=$(echo "$body" | jq -r '.request_id // empty')
          echo "request_id=$request_id" >> $GITHUB_OUTPUT

      - name: Run generated tests
        id: run_tests
        run: |
          echo "ðŸ§ª Running tests on backend..."
          
          # Read the response field from generated_tests.json (this contains the actual test code)
          generated_tests=$(cat generated_tests.json | jq -r '.response // .tests // .generated_tests // empty')
          
          if [ -z "$generated_tests" ] || [ "$generated_tests" = "null" ]; then
            echo "âŒ No tests found in generated_tests.json"
            echo "Contents of generated_tests.json:"
            cat generated_tests.json
            exit 1
          fi
          
          # Get the request_id from the generation response
          request_id=$(cat generated_tests.json | jq -r '.request_id // empty')
          
          # Decode the original source code
          source_code=$(echo "${{ steps.prepare_code.outputs.encoded_code }}" | base64 -d)
          
          # Build payload for test execution
          run_payload=$(python3 -c "
          import json

          test_code = '''$generated_tests'''
          source_code = '''$source_code'''
          language = '${{ steps.prepare_code.outputs.language }}'
          request_id = '$request_id'

          payload = {
              'test_code': test_code,
              'source_code': source_code,
              'language': language,
              'request_id': request_id
          }

          print(json.dumps(payload))
          ")
          
          # Execute tests via API
          response=$(curl -s -w "\n%{http_code}" -X POST "${{ secrets.BACKEND_URL }}/api/run-tests" \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$run_payload")
          
          # Split response and status code
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          
          echo "HTTP Status: $http_code"
          
          if [ "$http_code" != "200" ]; then
            echo "âš ï¸ Test execution completed with status $http_code"
            echo "Response: $body"
          fi
          
          echo "$body" > test_results.json
          echo "âœ… Test execution complete"
          
          # Extract execution_log_id from the results
          execution_log_id=$(echo "$body" | jq -r '.results.execution_log_id // .execution_log_id // empty')
          
          if [ -z "$execution_log_id" ] || [ "$execution_log_id" = "null" ]; then
            echo "âš ï¸ No execution_log_id found in response"
            echo "Response structure:"
            echo "$body" | jq '.'
            execution_log_id="$request_id"
          fi
          
          echo "result_id=$execution_log_id" >> $GITHUB_OUTPUT

      - name: Download JUnit XML results
        id: get_junit
        run: |
          echo "ðŸ“Š Fetching JUnit XML results..."
          
          result_id="${{ steps.run_tests.outputs.result_id }}"
          
          # Get JUnit XML from backend
          curl -s -X GET "${{ secrets.BACKEND_URL }}/api/results/${result_id}/junit" \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -o junit-results.xml
          
          if [ -f junit-results.xml ] && [ -s junit-results.xml ]; then
            echo "âœ… JUnit XML downloaded"
            echo "Preview:"
            head -n 20 junit-results.xml
          else
            echo "âš ï¸ JUnit XML file is empty or missing"
            # Create a basic JUnit XML as fallback
            cat > junit-results.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <testsuites name="AI Generated Tests" tests="0" failures="0" errors="0" skipped="0" time="0">
            <testsuite name="GenAI-QA" tests="0" failures="0" errors="0" skipped="0" time="0">
              <properties>
                <property name="status" value="No results available"/>
              </properties>
            </testsuite>
          </testsuites>
          EOF
                    fi

      - name: Publish test results
        uses: EnricoMi/publish-unit-test-result-action@v2
        if: always()
        with:
          files: junit-results.xml
          check_name: "AI Test Results"
          comment_title: "ðŸ¤– GenAI-QA Test Results"

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            generated_tests.json
            test_results.json
            junit-results.xml
          retention-days: 30
